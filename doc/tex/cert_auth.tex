\section{Certificate authentication}

% x.509 section
\subsection*{Authentication using X.509\index{X.509 certificates} certificates}

X.509 certificates contain the public parameters, 
of a public key algorithm, and an authority's signature, which proves the
authenticity of the parameters.
See section \ref{x509:trust} on page \pageref{x509:trust} for more information
on X.509 protocols.

% openpgp section

\subsection*{Authentication using OpenPGP\index{OpenPGP!Keys} keys}
\label{sec:pgp}

OpenPGP keys also contain public parameters of a public key algorithm, and
signatures from several other parties. Depending on whether a signer is
trusted the key is considered trusted or not.
\gnutls{}'s OpenPGP authentication implementation is based on the
\cite{TLSPGP} proposal.

See \ref{pgp:trust} on page \pageref{pgp:trust} for more information 
about the OpenPGP trust model. For a more detailed introduction to OpenPGP
and GnuPG see \cite{GPGH}.

\subsection*{Using certificate authentication}

In \gnutls{} both the OpenPGP and X.509 certificates are part of the
certificate authentication and thus are handled using a common API.
\par
When using certificates the server is required
to have at least one certificate and private key pair. A client
may or may not have such a pair. The certificate and key pair
should be loaded, before any \tls{} session is initialized,
in a certificate credentials structure. This should be done by using
\printfunc{gnutls_certificate_set_x509_key_file}{gnutls\_certificate\_set\_x509\_key\_file}
or
\printfunc{gnutls_certificate_set_openpgp_key_file}{gnutls\_certificate\_set\_openpgp\_key\_file}
depending on the certificate type. 
In the X.509 case, the functions will also accept and use a certificate list 
that leads to a trusted authority. The certificate list must be ordered in such
way that every certificate certifies the one before it. The trusted authority's
certificate need not to be included, since the peer should possess it already.
\par
As an alternative, a callback may be used
so the server or the client specify the certificate and the key at the handshake time.
That callback can be set using the functions:
\begin{itemize}
\item \printfunc{gnutls_certificate_server_set_retrieve_function}{gnutls\_certificate\_server\_set\_retrieve\_function}
\item \printfunc{gnutls_certificate_client_set_retrieve_function}{gnutls\_certificate\_client\_set\_retrieve\_function}
\end{itemize}
Certificate verification is possible by loading the trusted authorities
into the credentials structure by using
\printfunc{gnutls_certificate_set_x509_trust_file}{gnutls\_certificate\_set\_x509\_trust\_file}
or
\printfunc{gnutls_certificate_set_openpgp_keyring_file}{gnutls\_certificate\_set\_openpgp\_keyring\_file}
for openpgp keys. Note however that the peer's certificate is not automatically verified,
you should call \printfunc{gnutls_certificate_verify_peers}{gnutls\_certificate\_verify\_peers},
after a successful handshake,
to verify the signatures of the certificate. An alternative way, which reports
a more detailed verification output, is to use
\printfunc{gnutls_certificate_get_peers}{gnutls\_certificate\_get\_peers} to obtain
the raw certificate of the peer and verify it using the functions discussed in
section \ref{x509:trust} on page \pageref{x509:trust}. 

\par
In a handshake, the negotiated cipher suite depends on the 
certificate's parameters, so not all key exchange methods will be available
with some certificates. \gnutls{} will disable ciphersuites that are not compatible with the key, or
the enabled authentication methods. For example keys marked as sign-only, will not be able to
access the plain RSA ciphersuites, but only the DHE\_RSA ones. It is
recommended not to use RSA keys for both signing and encryption. If possible
use the same key for the DHE\_RSA and RSA\_EXPORT ciphersuites, which use signing,
and a different key for the plain RSA ciphersuites, which use encryption.
All the key exchange methods shown in \hyperref{figure}{figure }{}{fig:cert} are
available in certificate authentication. 

Note that the DHE key exchange methods are generally slower\footnote{It really depends
on the group used. Primes with lesser bits are always faster, but also easier to break. 
Values less than 768 should not be used today} 
than plain RSA and require Diffie Hellman parameters to be generated and associated with a credentials 
structure. The RSA-EXPORT method also requires 512 bit RSA parameters, that should 
also be generated and associated with the credentials structure. See the functions:
\begin{itemize}
\item \printfunc{gnutls_dh_params_generate2}{gnutls\_dh\_params\_generate2}
\item \printfunc{gnutls_certificate_set_dh_params}{gnutls\_certificate\_set\_dh\_params}
\item \printfunc{gnutls_rsa_params_generate2}{gnutls\_rsa\_params\_generate2}
\item \printfunc{gnutls_certificate_set_rsa_export_params}{gnutls\_certificate\_set\_rsa\_export\_params}
\end{itemize}

Sometimes in order to avoid bottlenecks in programs it is usefull to store
and read parameters from formats that can be generated by external programs such
as \emph{certtool}. This is possible with \emph{GnuTLS} by using the following
functions:

\begin{itemize}
\item \printfunc{gnutls_dh_params_import_pkcs3}{gnutls\_dh\_params\_import\_pkcs3}
\item \printfunc{gnutls_dh_params_export_pkcs3}{gnutls\_dh\_params\_export\_pkcs3}
\item \printfunc{gnutls_rsa_params_import_pkcs1}{gnutls\_rsa\_params\_import\_pkcs1}
\item \printfunc{gnutls_rsa_params_export_pkcs1}{gnutls\_rsa\_params\_export\_pkcs1}
\end{itemize}

\begin{figure}[hbtp]
\index{Key exchange algorithms}
\begin{tabular}{|l|p{9cm}|}
\hline
RSA & The RSA algorithm is used to encrypt a key and send it to the peer.
The certificate must allow the key to be used for encryption.
\\
\hline
RSA\_EXPORT & The RSA algorithm is used to encrypt a key and send it to the peer.
In the EXPORT algorithm, the server signs temporary RSA parameters of 512
bits -- which are considered weak -- and sends them to the client.
\\
\hline
DHE\_RSA & The RSA algorithm is used to sign Ephemeral Diffie Hellman
parameters which are sent to the peer. The key in the certificate must allow
the key to be used for signing. Note that key exchange algorithms which use
Ephemeral Diffie Hellman parameters, offer perfect forward secrecy. That means
that even if the private key used for signing is compromised, it cannot be
used to reveal past session data.
\\
\hline
DHE\_DSS & The DSS algorithm is used to sign Ephemeral Diffie Hellman
parameters which are sent to the peer. The certificate must contain DSA
parameters to use this key exchange algorithm. DSS stands for Digital Signature
Standard.
\\
\hline
\end{tabular}

\caption{Key exchange algorithms for OpenPGP and X.509 certificates.}
\label{fig:cert}

\end{figure}


